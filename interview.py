'''
v = dict.fromkeys(['k1','k2'],[])
v['k1'].append(666)
print(v)
v['k1'] = 777
print(v) #{'k1': [666], 'k2': [666]}  {'k1': 777, 'k2': [666]}'''

'''def num():
    return [lambda x:i*x for i in range(4)]
print([i for i in range(4)])
#print(num())
print ([m(2) for m in num()]) #[6, 6, 6, 6]'''

'''print("\n".join("\t".join(["%s*%s=%s" %(x,y,x*y) for y in range(1, x+1)]) for x in range(1, 10)))
#一行代码打印九九乘法表
print([ i % 2 for i in range(10) ]) #[0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
print( i % 2 for i in range(10) ) #<generator object <genexpr> at 0x000000000273CCA8>

python里面的坑: 函数的默认参数是一个list 
当第一次执行的时候实例化了一个list 
第二次执行还是用第一次执行的时候实例化的地址存储 
所以三次执行的结果就是 [1, 1, 1] 想每次执行只输出[1] ，默认参数应该设置为None


解释型和编译型编程语言的区别：
解释型语言编写的程序不需要编译，在执行的时候，专门有一个解释器能够将VB语言翻译成机器语言
每个语句都是执行的时候才翻译。这样解释型语言每执行一次就要翻译一次，效率比较低。

用编译型语言写的程序执行之前，需要一个专门的编译过程，通过编译系统，
把源高级程序编译成为机器语言文件，翻译只做了一次，运行时不需要翻译，
所以编译型语言的程序执行效率高，但也不能一概而论，

部分解释型语言的解释器通过在运行时动态优化代码，甚至能够使解释型语言的性能超过编译型语言。

求结果：
v1 = 1 or 3                    #解析：3 and 4即3与4为3，但是由于是短路操作符，结果为4，
v2 = 1 and 3                         是因为and运算符必须所有的运算数都是true才会把所有的运算数都解析，并且返回最后一个变量
v3 = 0 and 2 and 1                   即为4；改变一下顺序4 and 3 ，结果也不一样，即为3.
v4 = 0 and 2 or 1                    或逻辑（or），即只要有一个是true，即停止解析运算数
v5 = 0 and 2 or 1 or 4               返回最近为true的变量，即 3 or 4，值为3；改变顺序4 or 3 即为4.
v6 = 0 or False and 1                如果 x 为假，x 决定了结果为假，返回 x 0为假
print(v1,v2,v3,v4,v5,v6) #答案：1 3 0 1 1 False
